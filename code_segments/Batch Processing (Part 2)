#!/usr/bin/env python3
"""
MTG Proxy Enhancer - Batch Processing and Interface Components
Continuation from Part 1
"""

import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Event
from dataclasses import asdict
import json

class BatchProcessor:
    """High-performance batch processing with threading and progress tracking"""
    
    def __init__(self, enhancer_instance):
        self.enhancer = enhancer_instance
        self.stop_event = Event()
        
    def batch_process_threaded(self, settings: EnhancementSettings, 
                             max_workers: int = 4, overwrite: bool = True) -> Dict:
        """
        Multi-threaded batch processing for better performance
        """
        if not self.enhancer.images:
            logger.warning("No images to process")
            return {"success": 0, "errors": 0, "skipped": 0, "time": 0}
        
        self.enhancer.is_processing = True
        self.stop_event.clear()
        
        start_time = time.time()
        results = {"success": 0, "errors": 0, "skipped": 0, "time": 0}
        
        logger.info(f"Starting threaded batch processing with {max_workers} workers")
        logger.info(f"Processing {len(self.enhancer.images)} images")
        
        # Use ThreadPoolExecutor for parallel processing
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all tasks
            future_to_filename = {
                executor.submit(self.enhancer.process_single_image, filename, settings, overwrite): filename
                for filename in self.enhancer.images
            }
            
            # Process completed tasks
            for i, future in enumerate(as_completed(future_to_filename), 1):
                if self.stop_event.is_set():
                    logger.info(f"Processing stopped at image {i}")
                    break
                
                filename = future_to_filename[future]
                
                try:
                    success = future.result()
                    if success:
                        results["success"] += 1
                    else:
                        results["skipped"] += 1
                        
                    # Progress update
                    progress = i / len(self.enhancer.images) * 100
                    print(f"\rProgress: {i}/{len(self.enhancer.images)} [{progress:.1f}%] - {filename[:30]}", 
                          end="", flush=True)
                    
                except Exception as e:
                    logger.error(f"Error processing {filename}: {e}")
                    results["errors"] += 1
        
        results["time"] = time.time() - start_time
        self.enhancer.is_processing = False
        
        print(f"\n\nBatch processing complete!")
        print(f"Successfully processed: {results['success']} images")
        print(f"Skipped: {results['skipped']} images")
        print(f"Errors: {results['errors']} images")
        print(f"Time elapsed: {results['time']:.1f} seconds")
        print(f"Enhanced images saved to: {self.enhancer.output_folder}")
        
        return results
    
    def auto_batch_process(self, max_workers: int = 4) -> Dict:
        """
        Automatically analyze and enhance each image with optimal settings
        """
        if not self.enhancer.images:
            return {"success": 0, "errors": 0, "time": 0}
        
        self.enhancer.is_processing = True
        self.stop_event.clear()
        
        start_time = time.time()
        results = {"success": 0, "errors": 0, "time": 0}
        
        logger.info(f"Starting auto-enhancement with {max_workers} workers")
        
        def process_auto_enhance(filename):
            """Process single image with auto-enhancement"""
            try:
                input_path = self.enhancer.input_folder / filename
                output_path = self.enhancer.output_folder / filename
                
                # Load image
                img = cv2.imread(str(input_path))
                if img is None:
                    return False, f"Could not load {filename}"
                
                # Auto-enhance
                enhanced, settings, notes = self.enhancer.auto_enhance_image(img)
                
                # Save
                success = cv2.imwrite(str(output_path), enhanced, 
                                    [cv2.IMWRITE_JPEG_QUALITY, 95])
                
                return success, notes
                
            except Exception as e:
                return False, str(e)
        
        # Process with threading
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_filename = {
                executor.submit(process_auto_enhance, filename): filename
                for filename in self.enhancer.images
            }
            
            for i, future in enumerate(as_completed(future_to_filename), 1):
                if self.stop_event.is_set():
                    break
                
                filename = future_to_filename[future]
                
                try:
                    success, info = future.result()
                    if success:
                        results["success"] += 1
                    else:
                        results["errors"] += 1
                        logger.error(f"Failed: {filename} - {info}")
                    
                    progress = i / len(self.enhancer.images) * 100
                    print(f"\rAuto-enhancing: {filename[:30]} [{progress:.1f}%]", 
                          end="", flush=True)
                    
                except Exception as e:
                    logger.error(f"Error auto-enhancing {filename}: {e}")
                    results["errors"] += 1
        
        results["time"] = time.time() - start_time
        self.enhancer.is_processing = False
        
        print(f"\n\nAuto-enhancement complete!")
        print(f"Successfully processed: {results['success']} images")
        print(f"Errors: {results['errors']} images") 
        print(f"Time elapsed: {results['time']:.1f} seconds")
        
        return results
    
    def stop_processing(self):
        """Stop current batch processing"""
        self.stop_event.set()
        logger.info("Stop signal sent")

class SettingsManager:
    """Manage and persist enhancement settings"""
    
    @staticmethod
    def save_settings(settings: EnhancementSettings, filename: str = "enhancement_settings.json"):
        """Save settings to JSON file"""
        try:
            with open(filename, 'w') as f:
                json.dump(asdict(settings), f, indent=2)
            logger.info(f"Settings saved to {filename}")
        except Exception as e:
            logger.error(f"Failed to save settings: {e}")
    
    @staticmethod
    def load_settings(filename: str = "enhancement_settings.json") -> Optional[EnhancementSettings]:
        """Load settings from JSON file"""
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
            return EnhancementSettings(**data)
        except FileNotFoundError:
            logger.info(f"Settings file {filename} not found, using defaults")
            return None
        except Exception as e:
            logger.error(f"Failed to load settings: {e}")
            return None
    
    @staticmethod
    def create_preset_settings() -> Dict[str, EnhancementSettings]:
        """Create common preset configurations"""
        presets = {
            "default": EnhancementSettings(),
            
            "dark_images": EnhancementSettings(
                exposure=0.4, shadows=25, brightness=15, gamma=1.4, 
                clip_limit=3.0, clarity=10
            ),
            
            "bright_images": EnhancementSettings(
                highlights=-20, whites=-15, exposure=-0.2, gamma=0.9,
                clip_limit=1.5
            ),
            
            "low_contrast": EnhancementSettings(
                clip_limit=4.0, contrast=1.4, clarity=20, saturation=1.1,
                vibrance=15
            ),
            
            "color_enhancement": EnhancementSettings(
                saturation=1.3, vibrance=25, clarity=15, clip_limit=2.5
            ),
            
            "professional": EnhancementSettings(
                clip_limit=2.5, gamma=1.1, saturation=1.1, vibrance=10,
                clarity=12, highlights=-5, shadows=8
            ),
            
            "vintage_correction": EnhancementSettings(
                warmth=12, tint=-3, saturation=1.2, contrast=1.1,
                gamma=1.3, clarity=8
            )
        }
        
        return presets

# Enhanced utility functions
def create_mtg_enhancer(input_folder: str = "mtgproxy/Input", 
                       output_folder: str = "mtgproxy/Output") -> MTGProxyEnhancer:
    """Create optimized MTG Proxy Enhancer instance"""
    return MTGProxyEnhancer(input_folder, output_folder)

def quick_enhance_all(input_folder: str = "mtgproxy/Input", 
                     output_folder: str = "mtgproxy/Output",
                     preset: str = "default",
                     max_workers: int = 4) -> Dict:
    """Quick batch enhancement with preset or custom settings"""
    enhancer = MTGProxyEnhancer(input_folder, output_folder)
    batch_processor = BatchProcessor(enhancer)
    
    # Get preset settings
    presets = SettingsManager.create_preset_settings()
    settings = presets.get(preset, presets["default"])
    
    logger.info(f"Using preset: {preset}")
    return batch_processor.batch_process_threaded(settings, max_workers)

def auto_enhance_all(input_folder: str = "mtgproxy/Input", 
                    output_folder: str = "mtgproxy/Output",
                    max_workers: int = 4) -> Dict:
    """Auto-enhance all images using intelligent analysis"""
    enhancer = MTGProxyEnhancer(input_folder, output_folder)
    batch_processor = BatchProcessor(enhancer)
    
    return batch_processor.auto_batch_process(max_workers)

def benchmark_enhancement(input_folder: str = "mtgproxy/Input", 
                         test_count: int = 5) -> Dict:
    """
    Benchmark enhancement performance
    """
    enhancer = MTGProxyEnhancer(input_folder)
    
    if not enhancer.images:
        return {"error": "No images found"}
    
    # Test with first available image
    test_image_path = enhancer.input_folder / enhancer.images[0]
    img = cv2.imread(str(test_image_path))
    
    if img is None:
        return {"error": "Could not load test image"}
    
    settings = EnhancementSettings()
    
    # Warm-up run
    enhancer.enhance_image(img, settings)
    
    # Benchmark runs
    times = []
    for _ in range(test_count):
        start = time.time()
        enhancer.enhance_image(img, settings)
        times.append(time.time() - start)
    
    avg_time = np.mean(times)
    std_time = np.std(times)
    
    return {
        "image_size": f"{img.shape[1]}x{img.shape[0]}",
        "avg_time_ms": avg_time * 1000,
        "std_time_ms": std_time * 1000,
        "estimated_batch_time": avg_time * len(enhancer.images),
        "images_per_second": 1.0 / avg_time
    }

# CLI interface helper
def print_usage():
    """Print usage instructions"""
    print("""
🃏 MTG Proxy Enhancer - Optimized Version

QUICK START:
1. Place images in 'mtgproxy/Input' folder
2. Choose enhancement method:

📚 METHODS:
• Auto Enhancement (Recommended):
  auto_enhance_all()

• Preset Enhancement:
  quick_enhance_all(preset="professional")
  
• Custom Settings:
  enhancer = create_mtg_enhancer()
  settings = EnhancementSettings(gamma=1.3, saturation=1.2)
  BatchProcessor(enhancer).batch_process_threaded(settings)

📋 AVAILABLE PRESETS:
• "default" - Balanced enhancement
• "dark_images" - For underexposed cards
• "bright_images" - For overexposed cards  
• "low_contrast" - Boost contrast and clarity
• "color_enhancement" - Vibrant colors
• "professional" - Subtle professional look
• "vintage_correction" - Fix old/scanned cards

⚡ PERFORMANCE:
• Multi-threaded processing (4 workers by default)
